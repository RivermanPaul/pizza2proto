<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <title>Pizza vs Skeletons 2</title>
  <style>
    :root {
      color-scheme: dark;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #1a1630, #08060f 60%);
      color: #f4f4fb;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      user-select: none;
      -webkit-user-select: none;
      overflow: hidden;
      touch-action: none;
    }
    #game-layout {
      width: 100%;
      max-width: 960px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 24px 16px 48px;
      box-sizing: border-box;
    }
    #game-stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    canvas {
      display: block;
      width: 512px;
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      background: #0b0b17;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.55);
      image-rendering: pixelated;
    }
    #info {
      text-align: center;
      font-size: 14px;
      color: #b0aee0;
    }
    #info kbd {
      font-family: monospace;
      font-size: 12px;
      border: 1px solid #4a467f;
      border-radius: 4px;
      padding: 2px 6px;
      background: #1d1c35;
      color: #fff;
    }
    #touch-controls {
      display: flex;
      justify-content: center;
      gap: 18px;
      flex-wrap: wrap;
      margin-top: 12px;
      user-select: none;
      touch-action: manipulation;
    }
    #touch-controls .jump-button {
      margin-left: 12px;
    }
    #touch-controls button {
      width: 70px;
      height: 70px;
      border-radius: 18px;
      border: 2px solid #42405f;
      background: #1e1b34;
      color: #f4f4fb;
      font-size: 18px;
      font-weight: 600;
      text-transform: uppercase;
      box-shadow: inset 0 3px 0 rgba(255, 255, 255, 0.12);
      transition: transform 0.1s ease, background 0.1s ease;
    }
    #touch-controls button:active,
    #touch-controls button.active {
      transform: translateY(2px);
      background: #2f2951;
    }
    @media (max-width: 640px) {
      #game-layout {
        padding-bottom: 16px;
      }
      canvas {
        width: 100%;
      }
      #touch-controls button {
        width: 60px;
        height: 60px;
      }
    }
  </style>
</head>
<body>
  <div id="game-layout">
    <div id="game-stage">
      <canvas id="game" width="512" height="288"></canvas>
      <div id="info">
        Pizza vs Skeletons 2 — Controls:
        <kbd>A</kbd> roll left,
        <kbd>K</kbd> jump,
        <kbd>D</kbd> roll right
      </div>
    </div>
    <div id="touch-controls">
      <button data-input="left" aria-label="Move Left">◀</button>
      <button data-input="right" aria-label="Move Right">▶</button>
      <button class="jump-button" data-input="jump" aria-label="Jump">⬆</button>
    </div>
  </div>

  <script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js"></script>
  <script src="music.js"></script>
  <script src="enemies.js"></script>
  <script>
    // Canvas and audio bootstrap.
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const audio = window.AudioManager;
    audio.initAudio();
    const playSound = audio.playSound;

    const { Engine, Bodies, Body, Composite, Events } = Matter;

    const keys = {
      left: false,
      right: false,
      jump: false
    };
    let jumpQueued = false;

    // Update input map for keyboard/touch controls.
    function setKeyState(key, pressed) {
      if (key === 'left') keys.left = pressed;
      if (key === 'right') keys.right = pressed;
      if (key === 'jump') {
        keys.jump = pressed;
        if (pressed) {
          jumpQueued = true;
        }
      }
    }

    const keyboardMap = {
      ArrowLeft: 'left',
      KeyA: 'left',
      ArrowRight: 'right',
      KeyD: 'right',
      ArrowUp: 'jump',
      KeyK: 'jump',
      Space: 'jump',
      KeyW: 'jump'
    };

    window.addEventListener('keydown', (event) => {
      const mapped = keyboardMap[event.code];
      if (!mapped) return;
      event.preventDefault();
      setKeyState(mapped, true);
    });

    window.addEventListener('keyup', (event) => {
      const mapped = keyboardMap[event.code];
      if (!mapped) return;
      event.preventDefault();
      setKeyState(mapped, false);
    });

    // Wire up on-screen buttons so mobile players can roll and jump.
    const touchButtons = document.querySelectorAll('#touch-controls button');
    touchButtons.forEach((button) => {
      const input = button.dataset.input;
      const press = (event) => {
        event.preventDefault();
        button.classList.add('active');
        setKeyState(input, true);
      };
      const release = (event) => {
        event.preventDefault();
        button.classList.remove('active');
        setKeyState(input, false);
      };
      button.addEventListener('pointerdown', press);
      button.addEventListener('pointerup', release);
      button.addEventListener('pointerleave', release);
      button.addEventListener('pointercancel', release);
    });

    const pizza = {
      x: 140,
      y: 80,
      radius: 32,
      vx: 0,
      vy: 0,
      angle: 0,
      angVel: 0,
      grounded: false,
      health: 3,
      score: 0,
      invincibleTimer: 0
    };

    // Tunable physics constants for roll, jump, and clamp values.
    const physicsSettings = {
      rollForce: 0.0032,
      jumpSpeed: 10,
      maxSpeed: 4,
      gravity: 0.1,
      maxSpin: 4
    };

    const world = {
      gravity: 2600,
      width: 2600,
      floorY: canvas.height - 50
    };

    const camera = {
      x: 0
    };

    const platforms = [
      { x: -200, y: world.floorY, width: world.width + 400, height: 200 },
      { x: 160, y: world.floorY - 110, width: 200, height: 24 },
      { x: 520, y: world.floorY - 190, width: 180, height: 20 },
      { x: 840, y: world.floorY - 140, width: 170, height: 20 },
      { x: 1180, y: world.floorY - 80, width: 260, height: 20 },
      { x: 1520, y: world.floorY - 170, width: 200, height: 20 },
      { x: 1860, y: world.floorY - 110, width: 220, height: 24 },
      { x: 2200, y: world.floorY - 200, width: 200, height: 20 }
    ];

    const engine = Engine.create({ enableSleeping: false });
    engine.gravity.y = physicsSettings.gravity;
    engine.gravity.scale = 0.01;
    const physicsWorld = engine.world;

    // Create static Matter bodies for each platform.
    // Create static Matter bodies for each platform.
    const platformBodies = platforms.map((platform) => {
      const body = Bodies.rectangle(
        platform.x + platform.width / 2,
        platform.y + platform.height / 2,
        platform.width,
        platform.height,
        { isStatic: true, friction: 1, restitution: 0.0 }
      );
      Composite.add(physicsWorld, body);
      return { ...platform, body };
    });

    const boundaryThickness = 400;
    const leftWall = Bodies.rectangle(-boundaryThickness / 2, world.floorY, boundaryThickness, 4000, {
      isStatic: true
    });
    const rightWall = Bodies.rectangle(
      world.width + boundaryThickness / 2,
      world.floorY,
      boundaryThickness,
      4000,
      { isStatic: true }
    );
    Composite.add(physicsWorld, [leftWall, rightWall]);

    const pizzaBody = Bodies.circle(pizza.x, pizza.y, pizza.radius, {
      label: 'pizza',
      restitution: 0.0,
      friction: 0.35,
      frictionStatic: 1.2,
      frictionAir: 0.02,
      density: 0.004
    });
    Composite.add(physicsWorld, pizzaBody);

    const groundedContacts = new Set();
    let groundedCoyoteTimer = 0;
    // Track pizza-ground contacts and record when grounded.
    const trackGrounding = (pairs) => {
      for (const pair of pairs) {
        if (!pair || !pair.isActive) continue;
        const involvesPizza = pair.bodyA === pizzaBody || pair.bodyB === pizzaBody;
        if (!involvesPizza) continue;
        const other = pair.bodyA === pizzaBody ? pair.bodyB : pair.bodyA;
        if (!other || other.isSensor) continue;

        const supports = Array.isArray(pair.collision && pair.collision.supports)
          ? pair.collision.supports
          : [];
        let supportY = -Infinity;
        for (const point of supports) {
          if (point && typeof point.y === 'number') {
            supportY = Math.max(supportY, point.y);
          }
        }
        const groundThreshold = pizzaBody.position.y + pizza.radius * 0.35;

        const normal = (pair.collision && pair.collision.normal) || { x: 0, y: 0 };
        const pizzaIsA = pair.bodyA === pizzaBody;
        const normalY = pizzaIsA ? -normal.y : normal.y;

        if (supportY >= groundThreshold || normalY < -0.35) {
          groundedContacts.add(other.id);
          pizza.grounded = true;
        }
      }
    };

    Events.on(engine, 'collisionStart', (event) => {
      trackGrounding(event.pairs);
    });

    Events.on(engine, 'collisionActive', (event) => {
      groundedContacts.clear();
      trackGrounding(event.pairs);
      pizza.grounded = groundedContacts.size > 0;
    });

    Events.on(engine, 'collisionEnd', (event) => {
      for (const pair of event.pairs) {
        const involvesPizza = pair.bodyA === pizzaBody || pair.bodyB === pizzaBody;
        if (!involvesPizza) continue;
        const other = pair.bodyA === pizzaBody ? pair.bodyB : pair.bodyA;
        if (other && typeof other.id !== 'undefined') {
          groundedContacts.delete(other.id);
        }
      }
      pizza.grounded = groundedContacts.size > 0;
    });

    const enemies = window.EnemySystem;
    enemies.initSkeletons(world.floorY - 76);

    const particles = [];

    function spawnParticle(x, y, color) {
      particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 180,
        vy: -Math.random() * 220,
        life: 0.4 + Math.random() * 0.4,
        color
      });
    }

    function resetGame() {
      Body.setPosition(pizzaBody, { x: 140, y: 80 });
      Body.setVelocity(pizzaBody, { x: 0, y: 0 });
      Body.setAngle(pizzaBody, 0);
      Body.setAngularVelocity(pizzaBody, 0);
      groundedContacts.clear();
      pizza.grounded = false;
      pizza.score = 0;
      pizza.health = 3;
      pizza.invincibleTimer = 0;
      enemies.resetSkeletons(world.floorY - 76);
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        p.vy += world.gravity * 0.7 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
      }
    }

    function updatePizza(dt) {
      pizza.invincibleTimer = Math.max(0, pizza.invincibleTimer - dt);
      groundedCoyoteTimer = groundedContacts.size > 0
        ? 0.16
        : Math.max(0, groundedCoyoteTimer - dt);
      pizza.grounded = groundedCoyoteTimer > 0;

      const rollDir = (keys.left ? -1 : 0) + (keys.right ? 1 : 0);
      if (rollDir !== 0) {
        const rollForce = rollDir * physicsSettings.rollForce * pizzaBody.mass;
        Body.applyForce(pizzaBody, pizzaBody.position, { x: rollForce, y: 0 });
      }

      const clampedSpeed = Math.max(
        -physicsSettings.maxSpeed,
        Math.min(physicsSettings.maxSpeed, pizzaBody.velocity.x)
      );
      if (clampedSpeed !== pizzaBody.velocity.x) {
        Body.setVelocity(pizzaBody, { x: clampedSpeed, y: pizzaBody.velocity.y });
      }

      if (jumpQueued && pizza.grounded) {
        Body.setVelocity(pizzaBody, { x: pizzaBody.velocity.x, y: -physicsSettings.jumpSpeed });
        jumpQueued = false;
        playSound('jump');
      } else if (jumpQueued && !pizza.grounded) {
        jumpQueued = false;
      }

      Engine.update(engine, dt * 1000);

      const clampedSpin = Math.max(
        -physicsSettings.maxSpin,
        Math.min(physicsSettings.maxSpin, pizzaBody.angularVelocity)
      );
      if (clampedSpin !== pizzaBody.angularVelocity) {
        Body.setAngularVelocity(pizzaBody, clampedSpin);
      }

      pizza.x = pizzaBody.position.x;
      pizza.y = pizzaBody.position.y;
      pizza.vx = pizzaBody.velocity.x;
      pizza.vy = pizzaBody.velocity.y;
      pizza.angle = pizzaBody.angle;
      pizza.angVel = pizzaBody.angularVelocity;
    }

    function updateCamera() {
      const target = pizza.x - canvas.width * 0.5;
      const clampMax = world.width - canvas.width;
      const desired = Math.max(0, Math.min(clampMax, target));
      camera.x += (desired - camera.x) * 0.12;
    }

    function drawBackground() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#130f24');
      gradient.addColorStop(1, '#06040c');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#1b172f';
      for (let i = 0; i < 20; i++) {
        const hillX = ((i * 220) - camera.x * 0.25) % (canvas.width + 220) - 220;
        const hillY = canvas.height - 30;
        ctx.beginPath();
        ctx.ellipse(hillX, hillY, 160, 40, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 120; i++) {
        const starX = (i * 120 + i * 37) % (canvas.width + 500) - (camera.x * 0.08 % 500);
        const starY = (i * 53) % 200;
        ctx.beginPath();
        ctx.moveTo(starX, starY);
        ctx.lineTo(starX + 1, starY + 1);
        ctx.stroke();
      }
    }

    function drawPlatforms() {
      ctx.fillStyle = '#2c2b45';
      ctx.strokeStyle = '#5c537f';
      ctx.lineWidth = 2;
      for (const platform of platforms) {
        const x = platform.x - camera.x;
        ctx.fillRect(x, platform.y, platform.width, platform.height);
        ctx.strokeRect(x, platform.y, platform.width, platform.height);
      }
    }

    function drawPizza() {
      const renderX = pizza.x - camera.x;
      ctx.save();
      ctx.translate(renderX, pizza.y);
      ctx.rotate(pizza.angle);
      ctx.fillStyle = '#ffb347';
      ctx.beginPath();
      ctx.arc(0, 0, pizza.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#d65a31';
      for (let i = 0; i < 12; i++) {
        const angle = (Math.PI * 2 / 12) * i;
        const dotX = Math.cos(angle) * pizza.radius * 0.6;
        const dotY = Math.sin(angle) * pizza.radius * 0.6;
        ctx.beginPath();
        ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.strokeStyle = '#f7d08e';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(0, 0, pizza.radius - 6, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(0, p.life / 0.8);
        ctx.fillRect(p.x - camera.x, p.y, 4, 4);
        ctx.globalAlpha = 1;
      }
    }

    function drawHUD() {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(10, 10, 140, 60);
      ctx.fillStyle = '#ff4d6d';
      for (let i = 0; i < pizza.health; i++) {
        ctx.fillRect(20 + i * 24, 20, 18, 18);
      }
      ctx.fillStyle = '#ffffff';
      ctx.font = '14px monospace';
      ctx.fillText(`Score: ${pizza.score.toString().padStart(3, '0')}`, 20, 52);
      ctx.restore();
    }

    let lastTime = 0;
    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min(0.033, (timestamp - lastTime) / 1000);
      lastTime = timestamp;

      updatePizza(dt);
      enemies.updateSkeletons(dt, pizza, pizzaBody, physicsSettings, playSound, spawnParticle, resetGame);
      updateParticles(dt);
      updateCamera();

      drawBackground();
      drawPlatforms();
      enemies.drawSkeletons(ctx, camera.x);
      drawPizza();
      drawParticles();
      drawHUD();

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
