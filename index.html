<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <title>Pizza vs Skeletons 2</title>
  <style>
    :root {
      color-scheme: dark;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #1a1630, #08060f 60%);
      color: #f4f4fb;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      user-select: none;
      -webkit-user-select: none;
      overflow: hidden;
      touch-action: none;
    }
    #game-layout {
      width: 100%;
      max-width: 960px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 24px 16px 48px;
      box-sizing: border-box;
    }
    #game-stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    canvas {
      display: block;
      width: 512px;
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      background: #0b0b17;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.55);
      image-rendering: pixelated;
    }
    #info {
      text-align: center;
      font-size: 14px;
      color: #b0aee0;
    }
    #info kbd {
      font-family: monospace;
      font-size: 12px;
      border: 1px solid #4a467f;
      border-radius: 4px;
      padding: 2px 6px;
      background: #1d1c35;
      color: #fff;
    }
    #touch-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 18px;
      flex-wrap: wrap;
      margin-top: 12px;
      user-select: none;
      touch-action: manipulation;
    }
    #touch-controls .dpad {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    #touch-controls .dpad-row {
      display: flex;
      justify-content: center;
      gap: 10px;
      width: 100%;
    }
    #touch-controls .jump-button {
      margin-left: 12px;
    }
    #touch-controls button {
      width: 70px;
      height: 70px;
      border-radius: 18px;
      border: 2px solid #42405f;
      background: #1e1b34;
      color: #f4f4fb;
      font-size: 18px;
      font-weight: 600;
      text-transform: uppercase;
      box-shadow: inset 0 3px 0 rgba(255, 255, 255, 0.12);
      transition: transform 0.1s ease, background 0.1s ease;
    }
    #touch-controls .audio-toggle {
      height: 48px;
      width: auto;
      padding: 0 18px;
      border-radius: 12px;
      font-size: 14px;
      letter-spacing: 0.6px;
    }
    #touch-controls button:active,
    #touch-controls button.active {
      transform: translateY(2px);
      background: #2f2951;
    }
    @media (max-width: 640px) {
      #game-layout {
        padding-bottom: 16px;
      }
      canvas {
        width: 100%;
      }
      #touch-controls button {
        width: 60px;
        height: 60px;
      }
    }
  </style>
</head>
<body>
  <div id="game-layout">
    <div id="game-stage">
      <canvas id="game" width="512" height="288"></canvas>
      <div id="info">
        Pizza vs Skeletons 2 — Controls:
        <kbd>A</kbd> roll left,
        <kbd>K</kbd> or <kbd>Space</kbd> jump,
        <kbd>D</kbd> roll right,
        <kbd>W</kbd>/<kbd>↑</kbd> map up,
        <kbd>S</kbd>/<kbd>↓</kbd> map down
      </div>
    </div>
    <div id="touch-controls">
      <div class="dpad">
        <div class="dpad-row">
          <button data-input="up" aria-label="Move Up">▲</button>
        </div>
        <div class="dpad-row">
          <button data-input="left" aria-label="Move Left">◀</button>
          <button data-input="down" aria-label="Move Down">▼</button>
          <button data-input="right" aria-label="Move Right">▶</button>
        </div>
      </div>
      <button class="jump-button" data-input="jump" aria-label="Jump">⬆</button>
      <button id="mute-toggle" class="audio-toggle" aria-label="Toggle Audio"></button>
    </div>
  </div>

  <script src="matter.min.js"></script>
  <script src="music.js"></script>
  <script src="enemies.js"></script>
  <script src="lake.js"></script>
  <script src="overworld.js"></script>
  <script>
    // Canvas and audio bootstrap.
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const audio = window.AudioManager;
    audio.initAudio();
    // Start the game in a muted state so players can opt-in to audio.
    audio.setMuted(true);
    const playSound = audio.playSound;
    if (!window.Matter) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '16px monospace';
      ctx.fillText('Matter.js failed to load. Game halted.', 20, 40);
      throw new Error('Matter.js missing');
    }
    // Surface runtime errors directly on the canvas for easier local debugging.
    function drawErrorOverlay(message, source, lineno, colno) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '14px monospace';
      const msg = typeof message === 'string' ? message : 'Runtime error';
      ctx.fillText(msg, 10, 24);
      if (source) {
        ctx.fillText(`${source}:${lineno || 0}:${colno || 0}`, 10, 44);
      }
    }

    window.onerror = (message, source, lineno, colno) => {
      drawErrorOverlay(message, source, lineno, colno);
      return false;
    };

    const { Engine, Bodies, Body, Composite, Events } = Matter;

    const keys = {
      left: false,
      right: false,
      up: false,
      down: false,
      jump: false
    };
    let jumpQueued = false;

    // Game mode toggles that gate whether the player is in platforming, overworld exploration, or the lake variant.
    const gameModes = { PLATFORMER: 'platformer', OVERWORLD: 'overworld', LAKE: 'lake' };
    let currentMode = gameModes.PLATFORMER;
    let currentLevelId = 'stage1';

    // Overworld controller reference with safe fallbacks in case the module fails to load.
    const overworld = window.Overworld || {
      // No-op entry point used only when the overworld module fails to load.
      enter: () => {},
      // Idle update placeholder that keeps the game loop from breaking.
      update: () => null,
      // Blank draw placeholder so rendering keeps running without the module.
      draw: () => {},
      // Static node accessor placeholder used by HUD code.
      getCurrentNode: () => 'home'
    };

    // Lake mode controller reference used for level two's underwater variant.
    const lake = window.LakeMode || {
      // Reset lake state if the module fails to load so the game loop continues.
      enter: () => {},
      // No-op update to keep the main loop alive when lake mode is absent.
      update: () => null,
      // Blank draw placeholder so rendering keeps running without the module.
      draw: () => {}
    };

    // Update input map for keyboard/touch controls.
    function setKeyState(key, pressed) {
      // Normalize the mapping so individual or multi-action bindings work the same way.
      const actions = Array.isArray(key) ? key : [key];
      // Update each requested action flag in the shared keys map.
      for (const action of actions) {
        // Reflect horizontal left presses in the keys state.
        if (action === 'left') {
          keys.left = pressed;
        }
        // Reflect horizontal right presses in the keys state.
        if (action === 'right') {
          keys.right = pressed;
        }
        // Track upward navigation presses for overworld grid travel.
        if (action === 'up') {
          keys.up = pressed;
        }
        // Track downward navigation presses for overworld grid travel.
        if (action === 'down') {
          keys.down = pressed;
        }
        // Preserve the jump flag and queue to honor in-flight platformer jumps.
        if (action === 'jump') {
          keys.jump = pressed;
          if (pressed) {
            jumpQueued = true;
          }
        }
      }
    }

    const keyboardMap = {
      ArrowLeft: 'left',
      KeyA: 'left',
      ArrowRight: 'right',
      KeyD: 'right',
      ArrowUp: ['up', 'jump'],
      KeyW: ['up', 'jump'],
      ArrowDown: 'down',
      KeyS: 'down',
      KeyK: 'jump',
      Space: 'jump'
    };

    window.addEventListener('keydown', (event) => {
      const mapped = keyboardMap[event.code];
      // Skip keys that are not mapped so browser defaults can continue to run.
      if (!mapped) {
        return;
      }
      event.preventDefault();
      setKeyState(mapped, true);
    });

    window.addEventListener('keyup', (event) => {
      const mapped = keyboardMap[event.code];
      // Skip keys that are not mapped so browser defaults can continue to run.
      if (!mapped) {
        return;
      }
      event.preventDefault();
      setKeyState(mapped, false);
    });

    // Wire up on-screen buttons so mobile players can roll, jump, and move around the map.
    const touchButtons = document.querySelectorAll('#touch-controls button[data-input]');
    // Attach pointer listeners to each touch control button.
    touchButtons.forEach((button) => {
      const input = button.dataset.input;
      // Pointer down handler that marks the button pressed.
      const press = (event) => {
        event.preventDefault();
        button.classList.add('active');
        setKeyState(input, true);
      };
      // Pointer release handler that unsets the pressed state.
      const release = (event) => {
        event.preventDefault();
        button.classList.remove('active');
        setKeyState(input, false);
      };
      button.addEventListener('pointerdown', press);
      button.addEventListener('pointerup', release);
      button.addEventListener('pointerleave', release);
      button.addEventListener('pointercancel', release);
    });

    const muteToggle = document.getElementById('mute-toggle');
    // Update the mute button label so it reflects the current audio state.
    function refreshMuteLabel() {
      muteToggle.textContent = audio.isMuted() ? 'Unmute' : 'Mute';
    }
    // Toggle audio muting in response to user taps.
    muteToggle.addEventListener('click', () => {
      const nextMute = !audio.isMuted();
      // Flip the audio state to match the player's request.
      audio.setMuted(nextMute);
      // Unlock and start playback when the player unmutes.
      if (!nextMute) {
        audio.unlockAudio();
      }
      refreshMuteLabel();
    });
    refreshMuteLabel();

    const pizza = {
      x: 140,
      y: 80,
      radius: 32,
      vx: 0,
      vy: 0,
      angle: 0,
      angVel: 0,
      grounded: false,
      health: 3,
      score: 0,
      invincibleTimer: 0
    };

    // Tunable physics constants for roll, jump, and clamp values.
    const physicsSettings = {
      rollForce: 0.0032,
      jumpSpeed: 10,
      maxSpeed: 4,
      gravity: 0.2,
      maxSpin: 4,
      slamMultiplier: 1.5
    };

    const world = {
      gravity: 5200,
      width: 2600,
      floorY: canvas.height - 50
    };

    const camera = {
      x: 0
    };

    const platforms = [
      { x: -200, y: world.floorY, width: world.width + 400, height: 200 },
      { x: 160, y: world.floorY - 110, width: 200, height: 24 },
      { x: 520, y: world.floorY - 190, width: 180, height: 20 },
      { x: 840, y: world.floorY - 140, width: 170, height: 20 },
      { x: 1180, y: world.floorY - 80, width: 260, height: 20 },
      { x: 1520, y: world.floorY - 170, width: 200, height: 20 },
      { x: 1860, y: world.floorY - 110, width: 220, height: 24 },
      { x: 2200, y: world.floorY - 200, width: 200, height: 20 }
    ];

    const engine = Engine.create({ enableSleeping: false });
    engine.gravity.y = physicsSettings.gravity;
    engine.gravity.scale = 0.01;
    const physicsWorld = engine.world;

    // Create static Matter bodies for each platform.
    // Create static Matter bodies for each platform.
    const platformBodies = platforms.map((platform) => {
      const body = Bodies.rectangle(
        platform.x + platform.width / 2,
        platform.y + platform.height / 2,
        platform.width,
        platform.height,
        { isStatic: true, friction: 1, restitution: 0.0 }
      );
      Composite.add(physicsWorld, body);
      return { ...platform, body };
    });

    const boundaryThickness = 400;
    const rightWall = Bodies.rectangle(
      world.width + boundaryThickness / 2,
      world.floorY,
      boundaryThickness,
      4000,
      { isStatic: true }
    );
    Composite.add(physicsWorld, [rightWall]);

    const pizzaBody = Bodies.circle(pizza.x, pizza.y, pizza.radius, {
      label: 'pizza',
      restitution: 0.0,
      friction: 0.35,
      frictionStatic: 1.2,
      frictionAir: 0.02,
      density: 0.004
    });
    Composite.add(physicsWorld, pizzaBody);

    const groundedContacts = new Set();
    let groundedCoyoteTimer = 0;
    // Track how long the pizza has been physically off the ground to gate air actions.
    let airborneTimer = 0;
    // Track pizza-ground contacts and record when grounded.
    const trackGrounding = (pairs) => {
      for (const pair of pairs) {
        if (!pair || !pair.isActive) continue;
        const involvesPizza = pair.bodyA === pizzaBody || pair.bodyB === pizzaBody;
        if (!involvesPizza) continue;
        const other = pair.bodyA === pizzaBody ? pair.bodyB : pair.bodyA;
        if (!other || other.isSensor) continue;

        const supports = Array.isArray(pair.collision && pair.collision.supports)
          ? pair.collision.supports
          : [];
        let supportY = -Infinity;
        for (const point of supports) {
          if (point && typeof point.y === 'number') {
            supportY = Math.max(supportY, point.y);
          }
        }
        const groundThreshold = pizzaBody.position.y + pizza.radius * 0.35;

        const normal = (pair.collision && pair.collision.normal) || { x: 0, y: 0 };
        const pizzaIsA = pair.bodyA === pizzaBody;
        const normalY = pizzaIsA ? -normal.y : normal.y;

        if (supportY >= groundThreshold || normalY < -0.35) {
          groundedContacts.add(other.id);
          pizza.grounded = true;
        }
      }
    };

    Events.on(engine, 'collisionStart', (event) => {
      trackGrounding(event.pairs);
    });

    Events.on(engine, 'collisionActive', (event) => {
      groundedContacts.clear();
      trackGrounding(event.pairs);
      pizza.grounded = groundedContacts.size > 0;
    });

    Events.on(engine, 'collisionEnd', (event) => {
      for (const pair of event.pairs) {
        const involvesPizza = pair.bodyA === pizzaBody || pair.bodyB === pizzaBody;
        if (!involvesPizza) continue;
        const other = pair.bodyA === pizzaBody ? pair.bodyB : pair.bodyA;
        if (other && typeof other.id !== 'undefined') {
          groundedContacts.delete(other.id);
        }
      }
      pizza.grounded = groundedContacts.size > 0;
    });

    const enemies = window.EnemySystem || {
      initSkeletons: () => {},
      resetSkeletons: () => {},
      updateSkeletons: () => {},
      drawSkeletons: () => {}
    };
    enemies.initSkeletons(world.floorY - 76);

    const particles = [];

    function spawnParticle(x, y, color) {
      particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 180,
        vy: -Math.random() * 220,
        life: 0.4 + Math.random() * 0.4,
        color
      });
    }

    function resetGame() {
      Body.setPosition(pizzaBody, { x: 140, y: 80 });
      Body.setVelocity(pizzaBody, { x: 0, y: 0 });
      Body.setAngle(pizzaBody, 0);
      Body.setAngularVelocity(pizzaBody, 0);
      groundedContacts.clear();
      pizza.grounded = false;
      pizza.score = 0;
      pizza.health = 3;
      pizza.invincibleTimer = 0;
      enemies.resetSkeletons(world.floorY - 76);
    }

    // Moves the player into the overworld map when they roll beyond the left edge of the platforming space.
    function enterOverworld() {
      currentMode = gameModes.OVERWORLD;
      Body.setPosition(pizzaBody, { x: 140, y: 80 });
      Body.setVelocity(pizzaBody, { x: 0, y: 0 });
      Body.setAngle(pizzaBody, 0);
      Body.setAngularVelocity(pizzaBody, 0);
      overworld.enter(pizza.score);
    }

    // Restarts the appropriate stage from the overworld selection after the player confirms a level.
    function exitOverworld(levelId) {
      resetGame();
      currentLevelId = levelId || 'stage1';
      camera.x = 0;
      // Swap into the lake variant when launching level two.
      if (currentLevelId === 'stage2') {
        currentMode = gameModes.LAKE;
        lake.enter(playSound);
      } else {
        // Default to the physics-driven platformer for all other stages.
        currentMode = gameModes.PLATFORMER;
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        p.vy += world.gravity * 0.7 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
      }
    }

    function updatePizza(dt) {
      pizza.invincibleTimer = Math.max(0, pizza.invincibleTimer - dt);
      const isPhysicallyGrounded = groundedContacts.size > 0;
      groundedCoyoteTimer = isPhysicallyGrounded
        ? 0.16
        : Math.max(0, groundedCoyoteTimer - dt);
      pizza.grounded = groundedCoyoteTimer > 0;

      // Track air time so the slam input only works after a short hang time.
      if (isPhysicallyGrounded) {
        airborneTimer = 0;
      } else {
        airborneTimer += dt;
      }

      const rollDir = (keys.left ? -1 : 0) + (keys.right ? 1 : 0);
      if (rollDir !== 0) {
        const rollForce = rollDir * physicsSettings.rollForce * pizzaBody.mass;
        Body.applyForce(pizzaBody, pizzaBody.position, { x: rollForce, y: 0 });
      }

      const clampedSpeed = Math.max(
        -physicsSettings.maxSpeed,
        Math.min(physicsSettings.maxSpeed, pizzaBody.velocity.x)
      );
      if (clampedSpeed !== pizzaBody.velocity.x) {
        Body.setVelocity(pizzaBody, { x: clampedSpeed, y: pizzaBody.velocity.y });
      }

      // Trigger the normal jump when grounded, otherwise spend the queue on a slam if airborne long enough.
      if (jumpQueued && pizza.grounded) {
        Body.setVelocity(pizzaBody, { x: pizzaBody.velocity.x, y: -physicsSettings.jumpSpeed });
        jumpQueued = false;
        playSound('jump');
      } else if (jumpQueued && !pizza.grounded && airborneTimer > 0.25) {
        Body.setVelocity(pizzaBody, {
          x: pizzaBody.velocity.x,
          y: physicsSettings.jumpSpeed * physicsSettings.slamMultiplier
        });
        jumpQueued = false;
        playSound('jump');
      } else if (jumpQueued && !pizza.grounded) {
        jumpQueued = false;
      }

      Engine.update(engine, dt * 1000);

      const clampedSpin = Math.max(
        -physicsSettings.maxSpin,
        Math.min(physicsSettings.maxSpin, pizzaBody.angularVelocity)
      );
      if (clampedSpin !== pizzaBody.angularVelocity) {
        Body.setAngularVelocity(pizzaBody, clampedSpin);
      }

      pizza.x = pizzaBody.position.x;
      pizza.y = pizzaBody.position.y;
      pizza.vx = pizzaBody.velocity.x;
      pizza.vy = pizzaBody.velocity.y;
      pizza.angle = pizzaBody.angle;
      pizza.angVel = pizzaBody.angularVelocity;
    }

    function updateCamera() {
      const target = pizza.x - canvas.width * 0.5;
      const clampMax = world.width - canvas.width;
      const desired = Math.max(0, Math.min(clampMax, target));
      camera.x += (desired - camera.x) * 0.12;
    }

    function drawBackground() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#130f24');
      gradient.addColorStop(1, '#06040c');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#1b172f';
      for (let i = 0; i < 20; i++) {
        const hillX = ((i * 220) - camera.x * 0.25) % (canvas.width + 220) - 220;
        const hillY = canvas.height - 30;
        ctx.beginPath();
        ctx.ellipse(hillX, hillY, 160, 40, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 120; i++) {
        const starX = (i * 120 + i * 37) % (canvas.width + 500) - (camera.x * 0.08 % 500);
        const starY = (i * 53) % 200;
        ctx.beginPath();
        ctx.moveTo(starX, starY);
        ctx.lineTo(starX + 1, starY + 1);
        ctx.stroke();
      }
    }

    function drawPlatforms() {
      ctx.fillStyle = '#2c2b45';
      ctx.strokeStyle = '#5c537f';
      ctx.lineWidth = 2;
      for (const platform of platforms) {
        const x = platform.x - camera.x;
        ctx.fillRect(x, platform.y, platform.width, platform.height);
        ctx.strokeRect(x, platform.y, platform.width, platform.height);
      }
    }

    function drawPizza() {
      const renderX = pizza.x - camera.x;
      ctx.save();
      ctx.translate(renderX, pizza.y);
      ctx.rotate(pizza.angle);
      ctx.fillStyle = '#ffb347';
      ctx.beginPath();
      ctx.arc(0, 0, pizza.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#d65a31';
      for (let i = 0; i < 12; i++) {
        const angle = (Math.PI * 2 / 12) * i;
        const dotX = Math.cos(angle) * pizza.radius * 0.6;
        const dotY = Math.sin(angle) * pizza.radius * 0.6;
        ctx.beginPath();
        ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.strokeStyle = '#f7d08e';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(0, 0, pizza.radius - 6, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(0, p.life / 0.8);
        ctx.fillRect(p.x - camera.x, p.y, 4, 4);
        ctx.globalAlpha = 1;
      }
    }

    function drawHUD() {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(10, 10, 140, 60);
      ctx.fillStyle = '#ff4d6d';
      for (let i = 0; i < pizza.health; i++) {
        ctx.fillRect(20 + i * 24, 20, 18, 18);
      }
      ctx.fillStyle = '#ffffff';
      ctx.font = '14px monospace';
      ctx.fillText(`Score: ${pizza.score.toString().padStart(3, '0')}`, 20, 52);
      ctx.restore();
    }

    let lastTime = 0;
    function loop(timestamp) {
      // Initialize the previous time on the very first frame.
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min(0.033, (timestamp - lastTime) / 1000);
      lastTime = timestamp;

      try {
        // Run platformer updates when the player is inside the action stage.
        if (currentMode === gameModes.PLATFORMER) {
          updatePizza(dt);
          enemies.updateSkeletons(dt, pizza, pizzaBody, physicsSettings, playSound, spawnParticle, resetGame);
          updateParticles(dt);
          updateCamera();

          // When the pizza rolls off the left side, hop into the overworld map.
          if (pizza.x < -80) {
            enterOverworld();
          }

          // Only draw the platformer scene if the player has not swapped to the overworld mid-frame.
          if (currentMode === gameModes.PLATFORMER) {
            drawBackground();
            drawPlatforms();
            enemies.drawSkeletons(ctx, camera.x);
            drawPizza();
            drawParticles();
            drawHUD();
          } else {
            overworld.draw(ctx);
          }
        } else if (currentMode === gameModes.OVERWORLD) {
          // Drive overworld navigation when the player is outside the action stage.
          const overworldAction = overworld.update(dt, keys, playSound);
          overworld.draw(ctx);
          // Return to the action stage when the player confirms a level node.
          if (overworldAction && overworldAction.type === 'launch-level') {
            exitOverworld(overworldAction.from);
          }
        } else if (currentMode === gameModes.LAKE) {
          // Drive the underwater stage for level two.
          const lakeAction = lake.update(dt, keys, playSound);
          lake.draw(ctx);
          // Return to the overworld after winning the lake mode.
          if (lakeAction && lakeAction.type === 'return-to-map') {
            enterOverworld();
          }
        }
      } catch (err) {
        drawErrorOverlay(err && err.message ? err.message : String(err));
        return;
      }

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
